---
title: "X 月の Y ヶ月後・前が何月か問題を、数学的構造で考える"
date: 2025-08-25
---
# X 月の Y ヶ月後・前が何月か問題を、数学的構造で考える


## TL;DR

「X月のYヶ月後（前）」という一見単純な問題も、群論やモノイドといった数学的構造で捉え直すことで、条件分岐のない一般的な解法や、型安全な実装、さらには他の周期構造への応用が可能になります。HaskellやJavaScriptの畳み込み（fold/reduce）もモノイドの抽象化の恩恵を受けています。抽象化の力は、日常的な問題にも新たな発見をもたらします。

## 目次

1. [問題の概要](#問題の概要)
2. [モノイドとは？](#モノイドとは)
3. [直感的な解法とその課題](#直感的な解法とその課題)
4. [モノイド的な解法（Haskell例）](#モノイド的な解法haskell例)
5. [数学的構造による一般化](#数学的構造による一般化)
6. [単位元の導出と式変形](#単位元の導出と式変形)
7. [可換図式と構造保存](#可換図式と構造保存)
8. [まとめ・抽象化の意義](#まとめ抽象化の意義)

---


# 問題の概要

元問題: [AtCoder ABC420 A - Month](https://atcoder.jp/contests/abc420/tasks/abc420_a)

「X 月の Y ヶ月後は何月か？」という問題は、例えば「8 月の 5 ヶ月後は何月か？」のように、月を 1 から 12 までの整数で表し、Y ヶ月後の月を求めるものです。

---



## 直感的な解法とその課題

- 単純に `(X + Y) mod 12` を計算  
- 結果が 0 の場合だけ 12 に置き換える

```haskell
solve :: Int -> Int -> Int
solve x y =
  let r = (x + y) `mod` 12
  in if r == 0 then 12 else r
```

---

## 振り返り


この方法は制御ロジックがアドホックで、他のケースや応用への拡張が難しいと感じます。
というより、コンピュータ的な条件制御の思考を求められるのが辛いです。今回は問題が単純ですが、問題が複雑化すると、少し脳に負荷がかかります。

- 単純に `(X + Y) mod 12` を計算  
- 結果が 0 の場合だけ 12 に置き換える


```haskell
solve :: Int -> Int -> Int
solve x y =
  let r = (x + y) `mod` 12
  in if r == 0 then 12 else r
```

---



---


このようなアドホックな制御ロジックではなく、より「数学的な構造」としてこの問題を解きたいという動機がありました。その一つのアプローチが、モノイド的な構造を活用する方法です。
こうした抽象的な構造に乗せることで、条件分岐や例外処理から解放され、思考の負荷が大きく下がります。問題が複雑化しても、構造の力で自然に拡張できるのが嬉しいです。


## モノイド的な解法（Haskell例）

```haskell
import Text.Read (readMaybe)

type ErrorMessage = String

-- 1~12 の整数を表す型
newtype Range1To12 = Range1To12 Int

-- 入力 X, Y をラップ
newtype X = X Range1To12
newtype Y = Y Range1To12

-- 月を表す型
newtype Month = Month {unMonth :: Int}
  deriving (Eq, Show)

-- Range1To12 から Month を生成
mkMonth :: Range1To12 -> Month
mkMonth (Range1To12 x) = Month x

-- モノイド的加算
instance Semigroup Month where
  Month x <> Month y = Month $ ((x + y - 1) `mod` 12) + 1

instance Monoid Month where
  mempty = Month 12

-- 入力バリデーション
validate :: String -> Either ErrorMessage (X, Y)
validate input = case traverse readMaybe (words input) :: Maybe [Int] of
  Nothing -> Left "Invalid input"
  Just [x, y] ->
    if 1 <= x && x <= 12 && 1 <= y && y <= 12
      then Right (X (Range1To12 x), Y (Range1To12 y))
      else Left "Values must be between 1 and 12"
  _ -> Left "Invalid input"

-- 計算本体
solve :: X -> Y -> Int
solve (X x) (Y y) =
  let xm = mkMonth x
      xy = mkMonth y
   in unMonth (xm <> xy)

-- 入力から計算まで
main :: IO ()
main = do
  input <- getLine
  either print print $ validate input >>= \(x, y) -> return (solve x y)
```



## 数学的構造による一般化

まず、月を `{1, 2, ..., 12}` という有限集合として捉えます。この集合は暦上の月を表す整数であり、単純に「1 から 12 までの数」という形で扱います。

次に、この集合に対して **Month 型** を導入します。Month 型には巡回的な演算を定義しており、2つの Month を組み合わせると、自動的に 12 月を超えた分が循環するようになります。この演算は Haskell でいう `Semigroup` の `<>` や `Monoid` の `mempty` として実装できます。

こうすることで、例えば「X 月の Y ヶ月後」を求める計算は、単純に `Month X <> Month Y` と書くだけで自然に表現できます。演算内部で mod12 の処理が行われるため、条件分岐や 0 → 12 の置換を意識する必要はありません。

さらに、単位元 `mempty` を定義しておけば「0 ヶ月後」を自然に表現でき、逆元を導入すれば「Y ヶ月前」の計算も同じ型と演算で扱えます。


### ポイント

- `Month` 型に演算を定義することで、巡回構造を自然に扱える  
- 条件分岐なしで「Y ヶ月後」や「Y ヶ月前」が計算可能  
- 型安全に 1..12 の範囲を保証できる  
- 月だけでなく、曜日や時計などの周期構造にも応用可能


## 単位元の導出と式変形

Month 型で巡回加算を扱う場合、単位元 `mempty` を 12 月に設定します。

演算の定義：
Month x <> Month y = Month ((x + y - 1) mod 12 + 1)
mempty = Month 12

ここで、`X` 月の `Y` ヶ月後を計算するとします。

1. 式の書き下し
(X + Y - 1) mod 12 + 1

2. 単位元 `mempty = 12` を使って書き換え
(X + Y - 1) mod 12 + 1
= ((X - 1) + Y) mod 12 + 1

- `X - 1` は 1..12 の月を 0..11 の剰余群に対応させたもの  
- `Y` を加算した後、`mod 12` で巡回処理  
- 最後に `+1` することで 1..12 の月に戻す  

3. 結果の解釈

- `(X + Y - 1) mod 12 + 1 = r`  
- `r` が 1..12 の範囲に収まるため、条件分岐不要  
- `mempty = 12` を単位元に置くことで「0 → 12」の補正を自然に吸収


## 可換図式と構造保存

月の集合 `{1..12}` と剰余群 `Z/12Z` の間で可換になることを示す図：

```
       f
{1..12} ---> Z/12Z
   |             |
   |             | +Y mod12
   |             ▼
   |           Z/12Z
   |             |

   └---Month型演算--> {1..12}
     g
```
補足：今回書いたコードはこのg（{1..12}上での巡回演算）に相当します。明示的にZ/12Z上で「+y mod 12」を経由する形にはしていませんが、本質的には同じ構造を実装しています。


## 単位元の条件と導出

モノイドの単位元 $e$ は、任意の要素 $m$ に対して次を満たす必要があります：

- $e \oplus m = m \oplus e = m$

### 演算の定義

このモノイドの演算は次のように定義されます：

$$
e \oplus m = ((e + m - 1) \mod 12) + 1
$$

これが $m$ に一致するための条件を式変形で導きます。

1. 両辺から $1$ を引く：
  $$
  (e + m - 1) \mod 12 = m - 1
  $$
2. 両辺から $(m-1)$ を引く：
  $$
  (e + m - 1) - (m - 1) \equiv 0 \pmod{12}
  $$
  $$
  e \equiv 0 \pmod{12}
  $$

この結果から、単位元 $e$ は $e \equiv 0 \pmod{12}$ を満たす必要があります。

### 具体的な単位元

このモノイドの要素が $\{1,2,\ldots,12\}$ であると仮定すると、この条件を満たすのは $e=12$ です。



## まとめ・抽象化の意義

今回の「X 月の Y ヶ月後（前）が何月か」という一見単純な問題も、群論や圏論といった抽象的な数学的構造の視点から捉え直すことで、より一般的で拡張性のある解法や見通しの良い理解が得られることが分かります。

- **群論的視点** では、月の加算を巡回群（Z/12Z）の加法として扱うことで、条件分岐や例外処理を排除し、演算の本質を明確にできます。単位元や逆元の導入により、「Y ヶ月前」や「0 ヶ月後」も自然に扱えます。
- **型による抽象化**（HaskellのMonth型など）を用いることで、型安全かつ拡張性の高い実装が可能となり、曜日や時計など他の周期構造にも応用できます。
- **圏論的な視点** では、集合から群への写像・群での演算・集合への戻しという可換図式で、構造保存的な変換や抽象的な枠組みの意義が見えてきます。

もちろん、実用上は単純なmod計算で十分な場面が多いですが、こうした抽象的な枠組みを知っておくことで、より複雑な周期構造や他分野への応用、また「なぜこの式でうまくいくのか？」という根本的な納得感を得ることができます。

**まとめ**

- 群論や圏論は一見オーバースペックに思えますが、問題の本質や一般性、拡張性を与えてくれます。
- 型や構造を意識した設計は、実装の安全性・再利用性・可読性を高めます。
- 数学的な抽象化は、日常的な問題にも新たな視点や発見をもたらします。

このような「抽象化の力」を活かして、今後も様々な問題を捉え直していきたいと思います。

また、今回のような一見簡単な問題でも、数学的構造から捉え直すことで新たな発見や面白さが生まれることを改めて実感しました。